## 第一个程序：HelloWorld

[go语言在线运行](https://www.bejson.com/runcode/golang/)

```go
package main  //包名

import "fmt"   //程序中用到的库名

func main() {   //main函数
    fmt.Println("Hello world!")   //go语言不用;结尾
}
```



## 变量常量申明与基本类型

### 申明

go语言的一个特点是类型在变量名之后，以下三种**变量**申明方式等效：

- `var 变量名 类型 = 表达式` 

- `var 变量名 = 表达式` 让go自动类型推导

- `变量名 := 表达式` 让go自动类型推导，省略了var和变量类型

常量和变量不同在于使用`const`申明，如：`const name =  "飞雪无情"`。

### 基本类型

整型分为：

- **有符号整型**：如 int、int8、int16、int32 和 int64。
- **无符号整型**：如 uint、uint8、uint16、uint32 和 uint64。

浮点：float32 和 float64。

布尔值：true 和 false

字符串：类型 string，支持`+`操作来拼接字符串。



> 声明了一个变量，但是没有对其进行初始化，那么 Go 语言会自动初始化其值为对应类型的零值。比如数字类的零值是 0，布尔型的零值是 false，字符串的零值是 “” 空字符串等。



指针:Go语言中是有指针这个概念的，基本操作方式和C++类似：

```go
pi:=&i

*pi
```



## 其他

### 字符串和数字互转|不同数据类型的转换

不同数据类型转换：

```go
i2f:=float64(i)

f2i:=int(f64)
```

字符串与数字的转换：

```go
i2s:=strconv.Itoa(i)

s2i,err:=strconv.Atoi(i2s) //Go中函数是支持多返回值的，后面会讲到

fmt.Println(i2s,s2i,err)

```

通过包 strconv 的`Itoa`函数可以把一个 int 类型转为 string，Atoi 函数则用来把 string 转为 int。

同理对于浮点数、布尔型，Go语言提供了`strconv.ParseFloat`、`strconv.ParseBool`、`strconv.FormatFloat`和`strconv.FormatBool`进行互转，你可以自己试试。



### strings包

字符串和数字互相转换：Go SDK 为我们提供的一个标准包 `strings`。它是用于处理字符串的工具包，里面有很多常用的函数，帮助我们对字符串进行操作，比如查找字符串、去除字符串的空格、拆分字符串、判断字符串是否有某个前缀或者后缀等。掌握好它，有利于我们的高效编程。

## 控制结构：if、for、switch

### if

基本用法：

```go
if i >10 {
    fmt.Println("i>10")
} else if  i>5 && i<=10 {
    fmt.Println("5<i<=10")
} else {
    fmt.Println("i<=5")
}
```

在if中申明变量：

```go
if i:=6; i >10 { //在if中申明变量i
    fmt.Println("i>10")
} else if  i>5 && i<=10 {
    fmt.Println("5<i<=10")
} else {
    fmt.Println("i<=5")
}
```

### for

```go
sum:=0
for i:=1;i<=100;i++ {
    sum+=i
}
fmt.Println("the sum is",sum)
```

和其他语言一样，同样由于三部分组成：初值、判断、循环。

循环中仍然可以使用`continue`。

> Go中没有while循环，是通过for循环来实现的while循环，可见while一节。

### switch

```go
switch i:=6;{
case i>10:
    fmt.Println("i>10")
case i>5 && i<=10:
    fmt.Println("5<i<=10")
default:
    fmt.Println("i<=5")
}
```

**注意：** 不同于其他语言，Go中case之后默认是跳出的（自带break），如果想和其他语言一样不跳出，那么需要加入`fallthrough`关键字来取消跳出。



switch 后的表达式也没有太多限制，是一个合法的表达式即可，也不用一定要求是常量或者整数。

### while

Go中没有while循环，是通过for循环来实现的while循环：

```go
i:=1
for i<=100 {
    sum+=i
    i++
}
```

## 数组与map

### 数组(固定长度)

Array（数组）存放的是**固定长度**、**相同类型**的数据，而且这些存放的元素是连续的。所存放的数据类型没有限制，可以是整型、字符串甚至自定义。

> 固定长度表示Array的长度是不可变的。


#### 数组的申明
以下三种写法都是申明：长度为5、存放类型为string的`Array`。

```go
array:=[5]string{"a","b","c","d","e"}
```
```go
array:=[...]string{"a","b","c","d","e"} //省略长度的写法
```
```go
array1:=[5]string{1:"b",3:"d"} //只申明部分值的写法，其他默认为零值
```

> 注意：`[5]string` 和 `[4]string` 不是同一种类型，也就是说长度也是数组类型的一部分。

### 数组(动态长度)|切片

动态长度的数组成为Slice（切片），类似于C++的Vector和Java的ArrayList，其底层是长度连续的数组，且可以动态扩容。

#### 切片的申明

同样类似于C++的Vector的理解，Go中的Slice拥有长度（len）和容量（cap）的概念。

创建方式：

1. 使用`make`关键词

```go
slice1:=make([]string,4)   //方式1：指定长度为4
slice1:=make([]string,4,8)	//方式2：指定长度为4，容量为8
slice1:=[]string{"a","b","c","d","e"} //相对于申明Array，[]中没有...
```

2. 根据Array来创建

```go
array:=[5]string{"a","b","c","d","e"}

slice:=array[2:5] //同C++，包左不包右
```

> 包左不包右
> 
如果省略star或者end，那么star等价于0，end等价于最后一个index，比如：`array[:4]` 等价于 `array[0:4]`

**注意：基于数组的切片，使用的底层数组还是原来的数组，一旦修改切片的元素值，那么底层数组对应的值也会被修改。**

> 一般使用slice，而直接使用array比较少。

#### 切片的append

内置的 `append` 函数对一个切片追加元素，返回新切片。

```go
//追加一个元素
slice2:=append(slice1,"f")

//多加多个元素
slice2:=append(slice1,"f","g")

//追加另一个切片
slice2:=append(slice1,slice...)
```

关于append之后的新切片和append之前的切片是否共享底层，结论如下：

如果append之后不涉及扩容，即
$$
len(原来的Slice)+数量_{append} <= cap(原来的Slice)
$$
那么append之前与之后共享底层。

如果append之后会发生库容，那么append之前与之后不共享底层，相当于是创建了一个新的底层。

可用代码见证：

```go
package main

import (
	"fmt"
	//"reflect"
)

func main() {
	slice1 := make([]int, 1, 1) //声明一个切片，len为1，cap为1
	slice2 := append(slice1, 0)   //append之后发生扩容
	slice2[0] = 2
	fmt.Println(slice1)
	fmt.Println(slice2)
	fmt.Println("------------------------")
	slice1 = make([]int, 1, 2) //声明一个切片，len为1，cap为2
	slice2 = append(slice1, 0) //append之后不发生扩容
	slice2[0] = 2
	fmt.Println(slice1)
	fmt.Println(slice2)

}
/**
输出：
[0]
[2 0]
------------------------
[2]
[2 0]
*/
```



#### 数组|切片的循环访问：

两种方式：使用index的for循环 和 增强for循环。

**使用index 的for循环：**

```go
for i:=0;i<5;i++{
    fmt.Printf("数组索引:%d,对应值:%s\n", i, array[i])
}
```

**增强for循环**

```go
for i,v:=range array{
 	//i是索引index，v是具体的值
    fmt.Printf("数组索引:%d,对应值:%s\n", i, v)
}
```

#### 补充

##### string与[]byte

字符串 string 也是一个不可变的字节序列，所以可以直接转为字节切片 []byte ，基本操作：

```go
s:="Hello飞雪无情"

bs:=[]byte(s)

fmt.Println(bs)

fmt.Println(s[0],s[1],s[15])

fmt.Println(len(s)) //输出 17
```

需要注意的是：在这个示例中，字符串 s 里的字母和中文加起来不是 9 个字符吗？怎么可以使用 s[15] 超过 9 的索引呢？其实恰恰就是因为字符串是字节序列，每一个索引对应的是一个字节，而在 UTF8 编码下，一个汉字对应三个字节，所以字符串 s 的长度其实是 17。

如果你想把一个汉字当成一个长度计算，可以使用 utf8.RuneCountInString 函数。运行下面的代码，可以看到打印结果是 9，也就是 9 个 unicode（utf8）字符，和我们看到的字符的个数一致。

```go
fmt.Println(utf8.RuneCountInString(s))
```

而使用 for range 对字符串进行循环时，也恰好是按照 unicode 字符进行循环的，所以对于字符串 s 来说，循环了 9 次。

在下面示例的代码中，i 是索引，r 是 unicode 字符对应的 unicode 码点，**这也说明了 `for range` 循环在处理字符串的时候，会自动地隐式解码 `unicode` 字符串。**

### map与set

#### map

`map` 是一个无序的 K-V 键值对集合，结构为 `map[K]V`。其中 K 对应 Key，V 对应 Value。

`map` 中所有的 `Key` 必须具有相同的类型，`Value` 也同样，但 Key 和 Value 的类型可以不同。

**此外，Key 的类型必须支持 `==` 比较运算符，这样才可以判断它是否存在，并保证 Key 的唯一。**

##### map的声明与基本操作

这部分的基本操作与其他语言差距不大，稍微看一下应该就知道对应什么操作了。

```go
nameAgeMap:=make(map[string]int)  //make 创建map，key为string类型，value为int类型
```

```go
nameAgeMap["一山"] = 20   //没有key为“一山”，则创建这个key，有这个key则修改对应的值
```

```go
//获取指定 Key 对应的 Value
// 单个返回值
age:=nameAgeMap["一山"]

//多个返回值，分别对应：key对应的value，key是否存在
age,ok:=nameAgeMap["一山"]
```

```go
delete(nameAgeMap,"飞雪无情") //删除对应的key-value
```

```go
//类似于Go中的增强for循环，使用range关键词遍历map
for k,v:=range nameAgeMap{
    fmt.Println("Key is",k,",Value is",v)
}
```

> map 的遍历是无序的,**每次遍历，键值对的顺序可能会不一样。** 
>
> **注意：是每次遍历都可能不同，而不仅仅是key无序**
>
> 如果想按顺序遍历，可以先获取所有的 Key，并对 Key 排序，然后根据排序好的 Key 获取对应的 Value。

> for range map 的时候，也可以使用一个值返回。使用一个返回值的时候，这个返回值默认是 map 的 Key。

```go
fmt.Println(len(nameAgeMap)) //获取map的大小
```



#### set

Go中并没有提供现成的Set，但是可以通过`map`来曲线救国，基本思路：**只使用map中的key，value虽然存在但是不使用。**进阶一点：考虑到value占用空间，将value使用void来避免空间占用。

>  具体见：https://zhuanlan.zhihu.com/p/67580188

#### 拓展：

##### 如何实现key可以重复的map？

Go中不提供key可以重复的map，其中一个思路就是**将map的value设置为Slice**，用Slice存放重复的k、v。

### 函数与方法

2024-5-3：下方待开始

```\
https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/22%20%e8%ae%b2%e9%80%9a%e5%85%b3%20Go%20%e8%af%ad%e8%a8%80-%e5%ae%8c/05%20%20%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%b9%e6%b3%95%ef%bc%9aGo%20%e8%af%ad%e8%a8%80%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%b9%e6%b3%95%e5%88%b0%e5%ba%95%e6%9c%89%e4%bb%80%e4%b9%88%e4%b8%8d%e5%90%8c%ef%bc%9f.md
```



