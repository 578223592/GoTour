## Goroutines 和 Channels

<u>在正式开始之前，最好已经掌握了：并发、并行，进程、线程、协程的区别和联系。</u>



Go 语言中没有线程的概念，只有协程，也称为`goroutine`，一个程序可以随意启动成千上万个`goroutine`。



### 协程（Goroutine）

`goroutine`可以理解成go中的协程，需要并发执行其他函数的时候时候即可。

启动非常简单，`go function_name()`即可启动，如下：

```go
func main() {
   go fmt.Println("飞雪无情")
   fmt.Println("我是 main goroutine")
   time.Sleep(time.Second)
}
```





### Channel

#### **Channel是什么？用来解决什么问题？**

Channel是管道，用于解决多个goroutine之间通讯的问题，是并发安全的。

> 如果没有Channel，那么多个goroutine之间如何通信呢？
>
> 要么自行实现并发安全的队列，要么用共享变量+锁等方式，实在不优雅，Channel相当于go语言提供了一个并发安全的队列。

#### **Channel的声明**

```go
ch:=make(chan string)  //创建缓冲大小为0的channel
```

定义好 chan 后就可以使用了。

一个 chan 的操作只有两种：发送和接收。

1. 接收：获取 chan 中的值，操作符为 <- chan。
2. 发送：向 chan 发送值，把值放在 chan 中，操作符为 chan <-。

一个goruntime在接收Channel数据的时候，如果 ch 中没有值，则会**阻塞等待**到 ch 中有值可以接收为止。

#### channel的缓冲

Channel是可以在创建的时候设置缓冲大小的，比如：

```go
cacheCh:=make(chan int,5)  //缓冲大小为5
```



 channel 具备以下特点：

1. 有缓冲 channel 的内部有一个缓冲队列；
2. 发送操作是向队列的尾部插入元素，**如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间**；
3. 接收操作是从队列的头部获取元素并把它从队列中删除，**如果队列为空，则阻塞等待，直到另一个 goroutine 插入新的元素**。



#### channel的关闭

```go
close(cacheCh)
```



> 如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。



#### 单向 channel

channel是双向的，但是有时候需要限制一个 channel 只可以接收但是不能发送，或者限制一个 channel 只能发送但不能接收，这种 channel 称为单向 channel。

单向 channel 的声明也很简单，只需要在声明的时候带上 <- 操作符即可，如下面的代码所示：

```go
onlySend := make(chan<- int)
onlyReceive:=make(<-chan int)
```



> 如果说创建了一个只能发送或者只能接收数据的channel，那么数据发送过去之后如何接收呢？
>
> 所以一般情况下是用于函数中参数中限制channel的操作，而不是创建的时候。



在函数或者方法的参数中，使用单向 channel 的较多，这样可以防止一些操作影响了 channel。

下面示例中的 counter 函数，它的参数 out 是一个只能发送的 channel，所以在 counter 函数体内使用参数 out 时，只能对其进行发送操作，如果执行接收操作，则程序不能编译通过。

```go
func counter(out chan<- int) {
  //函数内容使用变量out，只能进行发送操作
}
```



#### select+channel 示例

> 此select非linux操作系统中IO多路复用的概念，只能说有相似的地方。

select + channel的组合和IO多路复用有点相似，可以达到优雅的监听多路channel的目的，任一channel都可以触发select。

语法：

```go
select {
   case i1 = <-c1:
     //todo
   case c2 <- i2:
	   //todo
   default:
	   // default todo
}
```





案例：

```go
func main() {

   //声明三个存放结果的channel
   firstCh := make(chan string)
   secondCh := make(chan string)
   threeCh := make(chan string)

   //同时开启3个goroutine下载
   go func() {
      firstCh <- downloadFile("firstCh")
   }()

   go func() {
      secondCh <- downloadFile("secondCh")
   }()

   go func() {
      threeCh <- downloadFile("threeCh")
   }()

   //开始select多路复用，哪个channel能获取到值，
   //就说明哪个最先下载好，就用哪个。
   select {
      case filePath := <-firstCh:
         fmt.Println(filePath)
      case filePath := <-secondCh:
         fmt.Println(filePath)
      case filePath := <-threeCh:
         fmt.Println(filePath)
   }
}
```

函数作用说明：下载三个文件，哪个下好了赋值给`filePath`，其他的就不管了。





#### 总结

在 Go 语言中，提倡通过通信来共享内存，而不是通过共享内存来通信，其实就是提倡通过 channel 发送接收消息的方式进行数据传递，而不是通过修改同一个变量。所以在**数据流动、传递的场景中要优先使用 channel，它是并发安全的，性能也不错。**











## 并发安全

<u>此章开始之前，希望你对并发安全、锁（互斥锁、读写锁）、资源竞争等有一些概念。</u>

并发安全部分主要内容：

- sync.Mutex：互斥锁
- sync.RWMutex 读写锁
- sync.WaitGroup 并发安全记数和等待

- sync.Once 保证函数只执行一次
- sync.Cond 条件变量

#### sync.Mutex

互斥锁

```go
var(
   sum int
   mutex sync.Mutex
)

func add(i int) {
   mutex.Lock()
   sum += i
   mutex.Unlock()  //解锁换成defer更加合适，这里是方便理解所以这么写
}
```



#### sync.RWMutex

读写锁

```go
var mutex sync.RWMutex
func readSum() int {

   //只获取读锁
   mutex.RLock()
   defer mutex.RUnlock()
   b:=sum

   return b

}
```

和其他语言相同，sync.RWMutex满足：读写互斥、写写互斥、读读不互斥。



#### sync.WaitGroup

sync.WaitGroup内部有一个值，可以做到阻塞等待到值为0的时候。



想象下面场景：

有没有办法监听所有协程的执行，一旦全部执行完毕，程序马上退出，这样既可保证所有协程执行完毕，又可以及时退出节省时间，提升性能。你第一时间应该会想到上节课讲到的 channel。没错，channel 的确可以解决这个问题，不过非常复杂，Go 语言为我们提供了更简洁的解决办法，它就是 sync.WaitGroup。







```go
func run(){

   var wg sync.WaitGroup

   //因为要监控110个协程，所以设置计数器为110
   wg.Add(110)
   for i := 0; i < 100; i++ {
      go func() {
         //计数器值减1
         defer wg.Done()
         add(10)
      }()
   }

   for i:=0; i<10;i++ {
      go func() {
         //计数器值减1
         defer wg.Done()
         fmt.Println("和为:",readSum())
      }()
   }

   //一直等待，只要计数器值为0
   wg.Wait()
}
```

sync.WaitGroup 的使用比较简单，一共分为三步：

1. 声明一个 `sync.WaitGroup`，然后通过 Add 方法设置计数器的值，需要跟踪多少个协程就设置多少，这里是 110；
2. 在每个协程执行完毕时调用 `Done` 方法，让计数器减 1，告诉 `sync.WaitGroup` 该协程已经执行完毕；
3. 最后调用 `Wait` 方法一直等待，直到计数器值为 0，也就是所有跟踪的协程都执行完毕。

>  `sync.WaitGroup`很像带有阻塞等待功能的并发安全的int。

sync.WaitGroup 适合协调多个协程共同做一件事情的场景，比如下载一个文件，假设使用 10 个协程，每个协程下载文件的 1⁄10 大小，只有 10 个协程都下载好了整个文件才算是下载好了。这就是我们经常听到的多线程下载，通过多个线程共同做一件事情，显著提高效率。





#### sync.Once

Go 语言为我们提供了 sync.Once 来保证代码只执行一次：

```go
func main() {
   doOnce()
}

func doOnce() {
   var once sync.Once
   onceBody := func() {
      fmt.Println("Only once")
   }

   //用于等待协程执行完毕
   done := make(chan bool)

   //启动10个协程执行once.Do(onceBody)
   for i := 0; i < 10; i++ {
      go func() {
         //把要执行的函数(方法)作为参数传给once.Do方法即可
         once.Do(onceBody)
         done <- true
      }()
   }

   for i := 0; i < 10; i++ {
      <-done
   }
}
```

这是 Go 语言自带的一个示例，虽然启动了 10 个协程来执行 onceBody 函数，但是因为用了 once.Do 方法，所以函数 onceBody 只会被执行一次。也就是说在高并发的情况下，`sync.Once` 也会保证 onceBody 函数只执行一次。

sync.Once 适用于创建某个对象的单例、只加载一次的资源等只执行一次的场景。

#### sync.Cond

sync.Cond 从字面意思看是条件变量，它具有阻塞协程和唤醒协程的功能，所以可以在满足一定条件的情况下唤醒协程，但条件变量只是它的一种使用场景。



```go
//10个人赛跑，1个裁判发号施令
func race(){

   cond :=sync.NewCond(&sync.Mutex{})
   var wg sync.WaitGroup
   wg.Add(11)

   for i:=0;i<10; i++ {
      go func(num int) {
         defer  wg.Done()
         fmt.Println(num,"号已经就位")
         cond.L.Lock()
         cond.Wait()//等待发令枪响
         fmt.Println(num,"号开始跑……")
         cond.L.Unlock()
      }(i)
   }

   //等待所有goroutine都进入wait状态
   time.Sleep(2*time.Second)

   go func() {
      defer  wg.Done()
      fmt.Println("裁判已经就位，准备发令枪")
      fmt.Println("比赛开始，大家准备跑")
      cond.Broadcast()//发令枪响
   }()
   //防止函数提前返回退出
   wg.Wait()
}
```

其基本使用和其他语言都是类似的，都是：加锁+等待这一步。



sync.Cond 有三个方法，它们分别是：

1. `Wait`，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。
2. `Signal`，唤醒一个等待时间最长的协程。
3. `Broadcast`，唤醒所有等待的协程。

> 注意：在调用 `Signal` 或者 `Broadcast` 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。



### 其他和总结

- 使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争







2024-5-7TODO

```
https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/22%20%e8%ae%b2%e9%80%9a%e5%85%b3%20Go%20%e8%af%ad%e8%a8%80-%e5%ae%8c/10%20%20Context%ef%bc%9a%e4%bd%a0%e5%bf%85%e9%a1%bb%e6%8e%8c%e6%8f%a1%e7%9a%84%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e7%a5%9e%e5%99%a8.md
```

















